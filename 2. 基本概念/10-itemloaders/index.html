<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <meta name="author" content="孔祥旭 qq:351469076 微信:kxx351469076">
  <link rel="shortcut icon" href="../../img/favicon.ico">
  <title>Item Loaders(Item加载器) - Scrapy 1.5.1 中文文档</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "Item Loaders(Item\u52a0\u8f7d\u5668)";
    var mkdocs_page_input_path = "2. \u57fa\u672c\u6982\u5ff5\\10-itemloaders.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js" defer></script>
  <script src="../../js/modernizr-2.8.3.min.js" defer></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> Scrapy 1.5.1 中文文档</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="../..">Home</a>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">1. 第一步</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../1. 第一步/01-index/">Scrapy 1.5 中文文档</a>
                </li>
                <li class="">
                    
    <a class="" href="../../1. 第一步/02-overview/">一眼了解Scrapy</a>
                </li>
                <li class="">
                    
    <a class="" href="../../1. 第一步/03-install/">安装指导</a>
                </li>
                <li class="">
                    
    <a class="" href="../../1. 第一步/04-scrapy tutorial/">Scrapy 教程</a>
                </li>
                <li class="">
                    
    <a class="" href="../../1. 第一步/05-examples/">例子</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">2. 基本概念</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../06-command_line_tool/">命令行工具</a>
                </li>
                <li class="">
                    
    <a class="" href="../07-spiders/">Spiders 自定义爬虫类</a>
                </li>
                <li class="">
                    
    <a class="" href="../08-selctor/">Selector 选择器</a>
                </li>
                <li class="">
                    
    <a class="" href="../09-items/">Items</a>
                </li>
                <li class=" current">
                    
    <a class="current" href="./">Item Loaders(Item加载器)</a>
    <ul class="subnav">
            
    <li class="toctree-l3"><a href="#item-loadersitem">Item Loaders(Item加载器)</a></li>
    
        <ul>
        
            <li><a class="toctree-l4" href="#item-loadersitems">使用Item Loaders填充items</a></li>
        
            <li><a class="toctree-l4" href="#_1">输入/输出 处理器</a></li>
        
            <li><a class="toctree-l4" href="#item-loaders">定义Item Loaders</a></li>
        
            <li><a class="toctree-l4" href="#_2">定义输入/输出处理器</a></li>
        
            <li><a class="toctree-l4" href="#item-loaders-context">Item Loaders Context</a></li>
        
            <li><a class="toctree-l4" href="#itemloader">ItemLoader对象</a></li>
        
            <li><a class="toctree-l4" href="#nested-loaders">Nested Loaders(嵌套加载器)</a></li>
        
            <li><a class="toctree-l4" href="#item-loaders_1">复用和扩展Item Loaders</a></li>
        
            <li><a class="toctree-l4" href="#_3">可用的内置处理器</a></li>
        
        </ul>
    

    </ul>
                </li>
                <li class="">
                    
    <a class="" href="../11-scrapy_shell/">Scrapy shell</a>
                </li>
                <li class="">
                    
    <a class="" href="../12-item_pipeline/">Item Pipeline</a>
                </li>
                <li class="">
                    
    <a class="" href="../13-feed_exports/">Feed exports</a>
                </li>
                <li class="">
                    
    <a class="" href="../14-requests_response/">Requests and Responses</a>
                </li>
                <li class="">
                    
    <a class="" href="../about/">about</a>
                </li>
    </ul>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">Scrapy 1.5.1 中文文档</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
        
          <li>2. 基本概念 &raquo;</li>
        
      
    
    <li>Item Loaders(Item加载器)</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="item-loadersitem">Item Loaders(Item加载器)</h1>
<p>Item Loaders提供了一种方便的机制来填充抓取的<a href="#">Items</a>。尽管items可以使用它们本身的字典API进行填充，但Item Loaders通过自动化一些常见任务(比如在分配原始提取的数据之前对其进行解析)，从抓取过程中填充它们Item Loaders提供了更方便的API。</p>
<p>换句话说，<a href="#">Items</a>提供了Scrapy抓取数据的容器，而Item Loaders提供了填充该容器的机制。</p>
<p>Item Loaders旨在提供一种灵活、高效和简单的机制，用于扩展和覆盖不同的字段的一种解析规则，无论是通过spider或源格式(HTML、XML等)进行扩展，而不会成为开发者维护的噩梦。</p>
<h2 id="item-loadersitems">使用Item Loaders填充items</h2>
<p>要使用Item Loaders，必须首先实例化它。您可以使用类似于dict的对象(例如Item或dict)来实例化它，也可以不使用它，在这种情况下，Item会使用<code>ItemLoader.default_item_class</code>属性中指定的Item类在ItemLoader构造函数中自动实例化。</p>
<p>然后，开始将值收集到Item Loader中，通常使用<a href="#">Selectors</a>。可以向同一item字段添加多个值;Item Loader将知道在以后如何使用适当的处理函数“连接”这些值。</p>
<p>下面是在<a href="#">Spider</a>中一个典型的Item Loaders的用法，在<a href="#">Item章节</a>中定义的<a href="#">Product item</a>:</p>
<pre><code class="python">from scrapy.loader import ItemLoader
from myproject.items import Product

def parse(self, response):
    l = ItemLoader(item=Product(), response=response)
    l.add_xpath('name', '//div[@class=&quot;product_name&quot;]')
    l.add_xpath('name', '//div[@class=&quot;product_title&quot;]')
    l.add_xpath('price', '//p[@id=&quot;price&quot;]')
    l.add_css('stock', 'p#stock]')
    l.add_value('last_updated', 'today') # 还可以使用文字值
    return l.load_item()
</code></pre>

<p>快速查看这段代码，我们可以看到name字段是从页面中的两个不同XPath位置提取的:</p>
<ol>
<li><code>//div[@class="product_name"]</code></li>
<li><code>//div[@class="product_title"]</code></li>
</ol>
<p>换句话说，通过使用<a href="#">add_xpath()</a>方法从两个XPath位置提取数据来收集数据。稍后将数据分配给<code>name</code>字段。</p>
<p>然后，对<code>price</code>和<code>stock</code>字段使用类似的调用(后者使用带有<a href="#">add_css()</a>方法的CSS选择器)，最后使用另一个方法<a href="#">add_value()</a>使用文字值(<code>today</code>)填充<code>last_update</code>字段。</p>
<p>最后，当所有数据收集完毕时，调用<a href="#">ItemLoader.load_item()</a>方法，该方法实际返回  被填充过的item(就是之前提取和收集的数据填充过的item), 只不过是在使用<a href="#">add_xpath()</a>、<a href="#">add_css()</a>和<a href="#">add_value()</a>之前。</p>
<h2 id="_1">输入/输出 处理器</h2>
<p>Item Loaders包含一个输入处理器和一个输出处理器，用于每个(item)字段。输入处理器在接收到提取的数据(通过<a href="#">add_xpath()</a>、<a href="#">add_css()</a>或<a href="#">add_value()</a>方法)时立即处理数据，并收集输入处理器的结果并保存在ItemLoader中。在收集所有数据之后，调用<a href="#">ItemLoader.load_item()</a>方法来填充和获取填充的<a href="#">Item</a>对象。这时，使用先前收集的数据(被输入处理器处理过的)调用输出处理器。输出处理器的结果是最终的值</p>
<p>让我们看一个例子来说明输入和输出处理器是如何被一个特定的字段(同样适用于任何其他字段)调用的:</p>
<pre><code class="python">l = ItemLoader(Product(), some_selector)
l.add_xpath('name', xpath1) # (1)
l.add_xpath('name', xpath2) # (2)
l.add_css('name', css) # (3)
l.add_value('name', 'test') # (4)
return l.load_item() # (5)
</code></pre>

<ol>
<li>提取<code>xpath1</code>中的数据，并通过<code>name</code>字段的输入处理器处理。输入处理器的结果被收集并保存在Item Loaders中(但尚未分配给Item)。</li>
<li>提取<code>xpath2</code>中的数据，并通过(1)中使用的相同的输入处理器处理，输入处理器的结果附加到(1)中收集的数据(如果有的话)。</li>
<li>这种情况与前面的情况类似，只是数据是从css css选择器中提取的，并通过(1)和(2)中使用的相同的输入处理器处理。</li>
<li>这种情况与前面的情况类似，只是要收集的值是直接分配的，而不是从XPath表达式或CSS选择器中提取的。但是，值仍然通过输入处理器传递。在本例中，由于该值不可迭代，因此在将其传递给输入处理器之前，将其转换为单个元素的可迭代值，因为输入处理器总是接收迭代值。</li>
<li>步骤(1)、(2)、(3)和(4)中收集的数据通过<code>name</code>字段的输出处理器处理。分配给item中的<code>name</code>字段的值是输出处理器的结果。</li>
</ol>
<p>值得注意的是，处理器只是可调用的对象，它与要解析的数据一起被调用，并返回被解析的值。因此，您可以使用任何函数作为输入或输出处理器。唯一的要求是他们必须接受一个(而且只有一个)位置参数，它将会是一个迭代器。</p>
<pre><code class="python">注意!!!!!!
输入和输出处理器都必须接收一个迭代器作为它们的第一个参数。
这些函数的输出可以是任何值。
输入处理器的结果将附加到一个内部列表(在Loader中)，
其中包含收集的值(用于该字段)。
最终分配给该item的值是输出处理器的结果。
</code></pre>

<p>如果你想使用一个普通函数作为处理器，确保它接收<code>self</code>作为第一个参数:</p>
<pre><code class="python">def lowercase_processor(self, values):
    for v in values:
        yield v.lower()

class MyItemLoader(ItemLoader):
    name_in = lowercase_processor
</code></pre>

<p>这是因为每当一个函数被赋值为类变量时，它就会变成一个方法，并在被调用时作为第一个参数传递实例。有关更多细节，请参阅<a href="https://stackoverflow.com/a/35322635">stackoverflow上的回答</a>。</p>
<p>您需要记住的另一件事是，输入处理器返回的值是在内部(在列表中)收集的，然后传递给输出处理器来填充字段的。</p>
<p>最后，但不是最终，Scrapy内置了一些<a href="#">常用的处理器</a>，以提供方便。</p>
<h2 id="item-loaders">定义Item Loaders</h2>
<p>通过使用类定义语法，可以像Item一样声明Item Loaders。这是一个例子:</p>
<pre><code class="python">from scrapy.loader import ItemLoader
from scrapy.loader.processors import TakeFirst, MapCompose, Join

class ProductLoader(ItemLoader):

    default_output_processor = TakeFirst()

    name_in = MapCompose(unicode.title)
    name_out = Join()

    price_in = MapCompose(unicode.strip)

    # ...
</code></pre>

<p>可以看到，输入处理器使用<code>_in</code>后缀定义，而输出处理器使用<code>_out</code>后缀定义。还可以使用<a href="#">ItemLoader.default_input_processor</a>和<a href="#">ItemLoader.default_output_processor</a>属性定义默认的输入/输出处理器。</p>
<h2 id="_2">定义输入/输出处理器</h2>
<p>如前一节所示，可以在Item Loader中定义输入和输出处理器，这样定义输入处理器是很常见的。但是，还有一个地方可以指定要使用的输入和输出处理器:在<a href="#">Item Field</a> metadata中。这是一个例子:</p>
<pre><code class="python">import scrapy
from scrapy.loader.processors import Join, MapCompose, TakeFirst
from w3lib.html import remove_tags

def filter_price(value):
    if value.isdigit():
        return value

class Product(scrapy.Item):
    name = scrapy.Field(
        input_processor=MapCompose(remove_tags),
        output_processor=Join(),
    )
    price = scrapy.Field(
        input_processor=MapCompose(remove_tags, filter_price),
        output_processor=TakeFirst(),
    )
</code></pre>

<pre><code class="python">&gt;&gt;&gt; from scrapy.loader import ItemLoader
&gt;&gt;&gt; il = ItemLoader(item=Product())
&gt;&gt;&gt; il.add_value('name', [u'Welcome to my', u'&lt;strong&gt;website&lt;/strong&gt;'])
&gt;&gt;&gt; il.add_value('price', [u'&amp;euro;', u'&lt;span&gt;1000&lt;/span&gt;'])
&gt;&gt;&gt; il.load_item()
{'name': u'Welcome to my website', 'price': u'1000'}
</code></pre>

<p>输入和输出处理器的优先顺序如下:</p>
<ol>
<li>
<p>Item Loader字段特定的属性:<code>field_in</code>和<code>field_out</code>(大多数优先级)</p>
</li>
<li>
<p>字段metadata(input_processor和output_processor键)</p>
</li>
<li>
<p>默认ItemLoader: <a href="#">ItemLoader.default_input_processor()</a>和<a href="#">ItemLoader.default_output_processor()</a>(最低优先级)</p>
</li>
</ol>
<p>参见:<a href="#">复用和扩展Item Loaders</a>。</p>
<h2 id="item-loaders-context">Item Loaders Context</h2>
<p>Item Loaders Context是Item Loaders中所有输入和输出处理器共享的任意键/值的字典。它可以在定义、实例化或使用Item Loaders时传递。它们用于修改输入/输出处理器的行为。</p>
<p>例如，假设您有一个函数<code>parse_length</code>，它接收一个文本值并从中提取一个长度:</p>
<pre><code class="python">def parse_length(text, loader_context):
    unit = loader_context.get('unit', 'm')
    # ... 解析长度的代码在这里 ...
    return parsed_length
</code></pre>

<p>通过接受<code>loader_context</code>参数，函数显式地告诉Item Loaders它可以接收一个Item Loaders Context，因此Item Loaders在调用它时传递当前活动的context，因此处理器函数(在本例中是<code>parse_length</code>)可以使用它们。</p>
<p>有几种方法可以修改项目Item Loader context值:</p>
<p>1.通过修改当前活动Item Loader context(<a href="#">context</a>属性):</p>
<pre><code class="python">loader = ItemLoader(product)
loader.context['unit'] = 'cm'
</code></pre>

<p>2.实例化Item Loader(Item Loader构造函数的关键字参数存储在Item Loader context中):</p>
<pre><code class="python">loader = ItemLoader(product, unit='cm')
</code></pre>

<p>3.定义Item Loader，对于那些支持用Item Loader context实例化它们的输入/输出处理器。MapCompose就是其中之一:</p>
<pre><code class="python">class ProductLoader(ItemLoader):
    length_out = MapCompose(parse_length, unit='cm')
</code></pre>

<h2 id="itemloader">ItemLoader对象</h2>
<h4 id="scrapyloaderitemloaderitem-selector-response-kwargs-class">scrapy.loader.ItemLoader([item, selector, response, ]**kwargs)   这是一个类(class)</h4>
<p>返回一个新的Item Loader来填充给定的Item。如果没有提供任何Item，则使用<a href="#">default_item_class</a>中的类自动实例化。</p>
<p>当使用选择器或response参数实例化时，<a href="#">ItemLoader</a>类提供了使用<a href="#">选择器</a>从web页面提取数据的方便机制。</p>
<blockquote>
<p>参数:</p>
<blockquote>
<p>item(<a href="#">Item</a>对象): 使用<a href="#">add_xpath()</a>、<a href="#">add_css()</a>或<a href="#">add_value()</a>的后续调用填充item实例。</p>
<p>selector(<a href="#">选择器</a>对象): 使用<a href="#">add_xpath()</a>(resp.<a href="#">add_css()</a>)或<a href="#">replace_xpath()</a>(resp.<a href="#">replace_css()</a>)方法时要从中提取数据的selector。</p>
<p>response(<a href="#">Response</a>对象): 使用<code>default_selector_class</code>构造selector的response，除非selector参数是给定的，在这种情况下，该参数被忽略。</p>
</blockquote>
</blockquote>
<p>item、selector、response和其余关键字参数被分配给Loader context(通过<a href="#">context</a>属性可访问)。</p>
<p><code>ItemLoader</code>实例有以下方法:</p>
<p><code>get_value(value, *processors, **kwargs)</code></p>
<blockquote>
<p>通过给定的<code>processors</code>和关键字参数处理给定的<code>value</code>。</p>
<p>可用关键字参数:</p>
<blockquote>
<p>参数:</p>
<blockquote>
<p>re(字符串或compiled regex): 用于使用<code>extract_regex()</code>方法从给定值中提取数据的正则表达式，在处理器之前应用</p>
</blockquote>
</blockquote>
<p>例子:</p>
</blockquote>
<pre><code>&gt;&gt;&gt; from scrapy.loader.processors import TakeFirst
&gt;&gt;&gt; loader.get_value(u'name: foo', TakeFirst(), unicode.upper, re='name: (.+)')
'FOO`
</code></pre>

<hr />
<p><code>add_value(field_name, value, *processors, **kwargs)</code></p>
<blockquote>
<p>处理给定的字段给定的值。</p>
<p>该值首先通过<a href="#">get_value()</a>传递给<code>processors</code>和<code>kwargs</code>，然后通过<a href="#">字段输入处理器</a>, 将其结果附加到为该字段收集的数据。如果字段已经包含已收集的数据，则添加新数据。</p>
<p>给定的<code>field_name</code>可以是<code>None</code>，在这种情况下，可能会添加多个字段的值。处理后的值应该是一个字典，其中field_name被映射到值。</p>
<p>例子:</p>
</blockquote>
<pre><code class="python">loader.add_value('name', u'Color TV')
loader.add_value('colours', [u'white', u'blue'])
loader.add_value('length', u'100')
loader.add_value('name', u'name: foo', TakeFirst(), re='name: (.+)')
loader.add_value(None, {'name': u'foo', 'sex': u'male'})
</code></pre>

<hr />
<p><code>replace_value(field_name, value, *processors, **kwargs)</code></p>
<blockquote>
<p>与<a href="#">add_value()</a>类似，但是使用新值替换收集的数据，而不是添加它。</p>
</blockquote>
<hr />
<p><code>get_xpath(xpath, *processors, **kwargs)</code></p>
<blockquote>
<p>与<a href="#">ItemLoader.get_value()</a>类似，但是接收的是XPath而不是值，该值用于从与这个<a href="#">ItemLoader</a>关联的选择器中提取unicode字符串列表。</p>
<blockquote>
<p>参数:</p>
<blockquote>
<p>xpath (str): 提取数据的Xpath路径
re (字符串或compiled regex): 用于从选定XPath区域提取数据的正则表达式</p>
</blockquote>
<p>例子:</p>
</blockquote>
</blockquote>
<pre><code class="python"># HTML片段: &lt;p class=&quot;product-name&quot;&gt;Color TV&lt;/p&gt;
loader.get_xpath('//p[@class=&quot;product-name&quot;]')
# HTML片段: &lt;p id=&quot;price&quot;&gt;the price is $1200&lt;/p&gt;
loader.get_xpath('//p[@id=&quot;price&quot;]', TakeFirst(), re='the price is (.*)')
</code></pre>

<hr />
<p><code>add_xpath(field_name, xpath, *processors, **kwargs)</code></p>
<blockquote>
<p>与<a href="#">ItemLoader.add_value()</a>类似，但是接收的是XPath而不是值，这个值用于从与这个<a href="#">ItemLoader</a>关联的选择器中提取unicode字符串列表。</p>
<p>看一下<a href="#">get_value()</a>的<code>kwargs</code></p>
<blockquote>
<p>参数: xpath(str): 用于提取数据的XPath</p>
</blockquote>
<p>例子:</p>
</blockquote>
<pre><code class="python"># HTML片段: &lt;p class=&quot;product-name&quot;&gt;Color TV&lt;/p&gt;
loader.add_xpath('name', '//p[@class=&quot;product-name&quot;]')
# HTML片段: &lt;p id=&quot;price&quot;&gt;the price is $1200&lt;/p&gt;
loader.add_xpath('price', '//p[@id=&quot;price&quot;]', re='the price is (.*)')
</code></pre>

<p><code>replace_xpath(field_name, xpath, *processors, **kwargs)</code></p>
<blockquote>
<p>类似于<a href="#">add_xpath()</a>，但是替换收集的数据而不是添加数据。</p>
</blockquote>
<hr />
<p><code>get_css(css, *processors, **kwargs)</code></p>
<blockquote>
<p>与<a href="#">ItemLoader.get_value()</a>类似，但是接收的是CSS选择器而不是值，该选择器用于从与这个<a href="#">ItemLoader</a>关联的选择器中提取unicode字符串列表。</p>
<blockquote>
<p>参数:</p>
<blockquote>
<p>css (字符串) – 要从中提取数据的CSS选择器</p>
<p>re (字符串或compiled regex) – 用于从选定的CSS区域中提取数据的正则表达式</p>
</blockquote>
</blockquote>
<p>例子:</p>
</blockquote>
<pre><code class="python"># HTML片段: &lt;p class=&quot;product-name&quot;&gt;Color TV&lt;/p&gt;
loader.get_css('p.product-name')
# HTML片段: &lt;p id=&quot;price&quot;&gt;the price is $1200&lt;/p&gt;
loader.get_css('p#price', TakeFirst(), re='the price is (.*)')
</code></pre>

<hr />
<p><code>add_css(field_name, css, *processors, **kwargs)</code></p>
<blockquote>
<p>与<a href="#">ItemLoader.add_value()</a>类似，但是接收的是CSS选择器而不是值，该选择器用于从与这个<a href="#">ItemLoader</a>关联的选择器中提取unicode字符串列表。</p>
<p>有关<code>kwargs</code>，请参阅<a href="#">get_css()</a>。</p>
<blockquote>
<p>参数:</p>
<blockquote>
<p>css (字符串) -用来提取数据的css选择器</p>
</blockquote>
</blockquote>
</blockquote>
<p>例子:</p>
<pre><code class="python"># HTML片段: &lt;p class=&quot;product-name&quot;&gt;Color TV&lt;/p&gt;
loader.add_css('name', 'p.product-name')
# HTML片段: &lt;p id=&quot;price&quot;&gt;the price is $1200&lt;/p&gt;
loader.add_css('price', 'p#price', re='the price is (.*)')
</code></pre>

<hr />
<p><code>replace_css(field_name, css, *processors, **kwargs)</code></p>
<blockquote>
<p>类似于<a href="#">add_css()</a>，但是替换收集的数据而不是添加数据。</p>
</blockquote>
<hr />
<p><code>load_item()</code></p>
<blockquote>
<p>用到目前为止收集的数据填充item，并返回它。首先通过<a href="#">输出处理器</a>获得收集到的数据，然后分配给item里每个字段的最终值。</p>
</blockquote>
<hr />
<p><code>nested_xpath(xpath)</code></p>
<blockquote>
<p>使用xpath选择器创建嵌套加载器(<strong>nested loader</strong>)。所提供的选择器相对于与此<a href="#">ItemLoader</a>关联的选择器。嵌套加载器与父项目加载器共享<a href="#">Item</a>，因此对<a href="#">add_xpath()</a>、<a href="#">dd_value()</a>、<a href="#">replace_value()</a>等的调用将按照预期执行。</p>
</blockquote>
<hr />
<p><code>nested_css(css)</code></p>
<blockquote>
<p>用css选择器创建嵌套加载器(<strong>nested loader</strong>)。所提供的选择器相对于与此<a href="#">ItemLoader</a>关联的选择器。嵌套加载器与父项目加载器共享<a href="#">Item</a>，因此对<a href="#">add_xpath()</a>、<a href="#">dd_value()</a>、<a href="#">replace_value()</a>等的调用将按照预期执行。</p>
</blockquote>
<hr />
<p><code>get_collected_values(field_name)</code></p>
<blockquote>
<p>返回给定字段收集到的值。</p>
</blockquote>
<hr />
<p><code>get_output_value(field_name)</code></p>
<blockquote>
<p>返回使用输出处理器对给定字段解析过后的收集到的值。此方法根本不填充或修改item。</p>
</blockquote>
<hr />
<p><code>get_input_processor(field_name)</code></p>
<blockquote>
<p>返回给定字段的输入处理器。</p>
</blockquote>
<hr />
<p><code>get_output_processor(field_name)</code></p>
<blockquote>
<p>返回给定字段的输出处理器。</p>
</blockquote>
<hr />
<hr />
<hr />
<p><a href="#">ItemLoader</a>实例具有以下属性:</p>
<p><code>item</code></p>
<blockquote>
<p>由Item Loader解析的<a href="#">Item</a>对象。</p>
</blockquote>
<p><code>context</code></p>
<blockquote>
<p>此Item Loader的当前活动<a href="#">上下文</a>。</p>
</blockquote>
<p><code>default_item_class</code></p>
<blockquote>
<p>一个Item类(或工厂)，用于在构造函数中未给出items时实例化items。</p>
</blockquote>
<p><code>default_input_processor</code></p>
<blockquote>
<p>未指定字段的默认输入处理器。</p>
</blockquote>
<p><code>default_output_processor</code></p>
<blockquote>
<p>未指定字段的默认输出处理器。</p>
</blockquote>
<p><code>default_selector_class</code></p>
<blockquote>
<p>如果构造函数中只给出response，则用于构造这个<a href="#">ItemLoader</a>的<a href="#">selector</a>的类。如果构造函数中提供了选择器，则忽略此属性。这个属性有时在子类中被重写。</p>
</blockquote>
<p><code>selector</code></p>
<blockquote>
<p>提取数据的<a href="#">selector</a>对象。它要么是构造函数中给出的selector，要么是使用<a href="#">default_selector_class</a>从构造函数中给出的response创建的selector。这个属性是只读的。</p>
</blockquote>
<h2 id="nested-loaders">Nested Loaders(嵌套加载器)</h2>
<p>当从文档的一个小节解析相关值时，创建嵌套加载器是很有用的。假设您正在从页面的页脚中提取细节，这些页脚看起来如下:</p>
<p>例子:</p>
<pre><code class="html">&lt;footer&gt;
    &lt;a class=&quot;social&quot; href=&quot;https://facebook.com/whatever&quot;&gt;Like Us&lt;/a&gt;
    &lt;a class=&quot;social&quot; href=&quot;https://twitter.com/whatever&quot;&gt;Follow Us&lt;/a&gt;
    &lt;a class=&quot;email&quot; href=&quot;mailto:whatever@example.com&quot;&gt;Email Us&lt;/a&gt;
&lt;/footer&gt;
</code></pre>

<p>没有嵌套加载器，您需要为您希望提取的每个值指定完整的xpath(或css)。</p>
<p>例子:</p>
<pre><code class="python">loader = ItemLoader(item=Item())
# 加载的东西不在页脚
loader.add_xpath('social', '//footer/a[@class = &quot;social&quot;]/@href')
loader.add_xpath('email', '//footer/a[@class = &quot;email&quot;]/@href')
loader.load_item()
</code></pre>

<p>相反，您可以使用footer选择器创建一个嵌套的加载器，并添加相对于footer的值。功能是相同的，但您可以避免重复footer选择器。</p>
<p>例子:</p>
<pre><code class="python">loader = ItemLoader(item=Item())
# 加载的东西不在页脚
footer_loader = loader.nested_xpath('//footer')
footer_loader.add_xpath('social', 'a[@class = &quot;social&quot;]/@href')
footer_loader.add_xpath('email', 'a[@class = &quot;email&quot;]/@href')
# 不需要调用footer_loader.load_item()
loader.load_item()
</code></pre>

<p>可以任意嵌套加载器，它们可以使用xpath或css选择器。作为一个通用方法，嵌套加载器使代码更简单，但又不过分嵌套，或者解析器可能变得难以阅读时，使用嵌套加载器。</p>
<h2 id="item-loaders_1">复用和扩展Item Loaders</h2>
<p>随着项目越来越大，有越来越多的spider，维护就成为一个基本问题，特别是当您必须为每个爬行器处理许多不同的解析规则时，有许多异常，但还需要复用公共输入输出处理器时。</p>
<p>Item Loaders旨在减轻解析规则的维护负担，同时不丧失灵活性，并为扩展和覆盖规则提供方便的机制。因此，Item Loaders支持传统的Python类继承，以处理特定spider(或spider组)的差异。</p>
<p>例如，假设某个特定站点将它们的产品名称用三个横杠括起来(例如<code>--- plasma TV---</code>)，并且您不希望在最终产品名称中使用这些横杠。</p>
<p>下面介绍如何通过复用和扩展默认Product的Item Loaders(<code>ProductLoader</code>)来删除这些横杠:</p>
<pre><code class="python">from scrapy.loader.processors import MapCompose
from myproject.ItemLoaders import ProductLoader

def strip_dashes(x):
    return x.strip('-')

class SiteSpecificLoader(ProductLoader):
    name_in = MapCompose(strip_dashes, ProductLoader.name_in)
</code></pre>

<p>扩展Item Loaders非常有用的另一种情况是，当您有多种源格式时，例如XML和HTML。在XML版本中，您可能希望删除出现的<code>CDATA</code>。下面是一个如何做到这一点的例子:</p>
<pre><code class="python">from scrapy.loader.processors import MapCompose
from myproject.ItemLoaders import ProductLoader
from myproject.utils.xml import remove_cdata

class XmlProductLoader(ProductLoader):
    name_in = MapCompose(remove_cdata, ProductLoader.name_in)
</code></pre>

<p>这就是通常扩展输入处理器的方式。</p>
<p>对于输出处理器，更常见的做法是在字段metadata中定义它们，因为它们通常只依赖于字段，而不依赖于每个特定的站点解析规则(如输入处理器)。参见:<a href="#">输入和输出处理器的定义</a>。</p>
<p>有许多其他可能的方法可以扩展、继承和覆盖Item Loaders，不同的Item Loaders层次结构可能更适合不同的项目。Scrapy只提供机制;它不会强制您的装载器集合的任何特定组织——这取决于您和您的项目的需求。</p>
<h2 id="_3">可用的内置处理器</h2>
<p>尽管您可以使用任何可调用函数作为输入和输出处理器，但Scrapy提供了一些常用的处理器，如下所述。其中一些函数，如<a href="#">MapCompose</a>(通常用作输入处理器)，负责组合按顺序执行的几个函数的输出，以生成最终解析后的值。</p>
<p>下面是所有内置处理器的列表:</p>
<h4 id="scrapyloaderprocessorsidentity-class">scrapy.loader.processors.Identity   这是一个类(class)</h4>
<blockquote>
<p>最简单的处理器，什么都不做。它返回原值不变。它不接收任何构造函数参数，也不接受加载器上下文。</p>
</blockquote>
<p>例子:</p>
<pre><code class="shell">&gt;&gt;&gt; from scrapy.loader.processors import Identity
&gt;&gt;&gt; proc = Identity()
&gt;&gt;&gt; proc(['one', 'two', 'three'])
['one', 'two', 'three']
</code></pre>

<h4 id="scrapyloaderprocessorstakefirst-class">scrapy.loader.processors.TakeFirst   这是一个类(class)</h4>
<blockquote>
<p>从接收到的值返回第一个非空/非空值，因此它通常作为输出处理器用于单值字段。它不接收任何构造函数参数，也不接受加载器上下文。</p>
</blockquote>
<p>例子:</p>
<pre><code class="shell">&gt;&gt;&gt; from scrapy.loader.processors import TakeFirst
&gt;&gt;&gt; proc = TakeFirst()
&gt;&gt;&gt; proc(['', 'one', 'two', 'three'])
'one'
</code></pre>

<h4 id="scrapyloaderprocessorsjoinseparatoru-class">scrapy.loader.processors.Join(separator=u' ')   这是一个类(class)</h4>
<blockquote>
<p>返回与构造函数中给出的分隔符连接的值，该分隔符默认为u' '。它不接受加载器上下文。</p>
<p>当使用默认分隔符时，这个处理器相当于函数:<code>u' '.join</code></p>
</blockquote>
<p>例子:</p>
<pre><code class="shell">&gt;&gt;&gt; from scrapy.loader.processors import Join
&gt;&gt;&gt; proc = Join()
&gt;&gt;&gt; proc(['one', 'two', 'three'])
u'one two three'
&gt;&gt;&gt; proc = Join('&lt;br&gt;')
&gt;&gt;&gt; proc(['one', 'two', 'three'])
u'one&lt;br&gt;two&lt;br&gt;three'
</code></pre>

<h4 id="scrapyloaderprocessorscompose42functions-4242default_loader_context-class">scrapy.loader.processors.Compose(*functions, **default_loader_context)   这是一个类(class)</h4>
<blockquote>
<p>由给定函数的组合构成的处理器。这意味着这个处理器的每个输入值都被传递给第一个函数，这个函数的结果被传递给第二个函数，以此类推，直到最后一个函数返回这个处理器的输出值。</p>
<p>默认情况下，在<code>None</code>值上停止处理。通过传递关键字参数<code>stop_on_none=False</code>可以改变这种行为。</p>
</blockquote>
<p>例子</p>
<pre><code class="shell">&gt;&gt;&gt; from scrapy.loader.processors import Compose
&gt;&gt;&gt; proc = Compose(lambda v: v[0], str.upper)
&gt;&gt;&gt; proc(['hello', 'world'])
'HELLO'
</code></pre>

<p>每个函数都可以选择接收<code>loader_context</code>参数。对于这样做的，这个处理器将通过该参数传递当前活动<a href="#">加载器上下文</a>。</p>
<p>在构造函数中传递的关键字参数用作传递给每个函数调用的默认是加载器上下文值。但是，传递给函数的最终加载器上下文值被通过<code>ItemLoader.context()</code>属性访问的当前活动加载器上下文覆盖。</p>
<h4 id="scrapyloaderprocessorsmapcompose42functions-4242default_loader_context-class">scrapy.loader.processors.MapCompose(*functions, **default_loader_context)   这是一个类(class)</h4>
<blockquote>
<p>由给定函数的组合构成的处理器，类似于构成<code>Compose</code>处理器。这个处理器的不同之处在于内部结果在函数之间传递的方式，如下所示:</p>
<p>迭代该处理器的输入值，并对每个元素应用第一个函数。这些函数调用的结果(每个元素一个)被连接起来，以构造一个新的iterable，然后使用它应用第二个函数，依此类推，直到最后一个函数应用到到目前为止收集的值列表的每个值为止。最后一个函数的输出值被连接在一起以产生这个处理器的输出。</p>
<p>每个特定的函数都可以返回一个值或一个值列表，这个值列表与应用于其他输入值的相同函数返回的值列表是相同的。函数还可以返回<code>None</code>，在这种情况下，该函数的输出将被忽略，以便在链上进行进一步处理。</p>
<p>这个处理器提供了一种方便的方法来组合只使用单个值(而不是迭代)的函数。由于这个原因，MapCompose处理器通常用作输入处理器，因为数据通常是使用选择器的extract()方法提取的，这个方法返回一个unicode字符串列表。</p>
</blockquote>
<p>下面的例子应该说明它是如何工作的::</p>
<pre><code class="shell">&gt;&gt;&gt; def filter_world(x):
...     return None if x == 'world' else x
...
&gt;&gt;&gt; from scrapy.loader.processors import MapCompose
&gt;&gt;&gt; proc = MapCompose(filter_world, unicode.upper)
&gt;&gt;&gt; proc([u'hello', u'world', u'this', u'is', u'scrapy'])
[u'HELLO, u'THIS', u'IS', u'SCRAPY']
</code></pre>

<p>与Compose处理器一样，函数可以接收装载器上下文，而构造函数关键字参数被用作默认上下文值。有关更多信息，请参阅<a href="#">Compose</a>处理器。</p>
<h4 id="scrapyloaderprocessorsselectjmesjson_path-class">scrapy.loader.processors.SelectJmes(json_path)   这是一个类(class)</h4>
<blockquote>
<p>使用提供给构造函数的json路径查询值并返回输出。需要运行jmespath (<a href="https://github.com/jmespath/jmespath.py">https://github.com/jmespath/jmespath.py</a>)。这个处理器一次只接受一个输入。</p>
<p>例子:</p>
</blockquote>
<pre><code class="shell">&gt;&gt;&gt; from scrapy.loader.processors import SelectJmes, Compose, MapCompose
&gt;&gt;&gt; proc = SelectJmes(&quot;foo&quot;) # 直接用于列表和字典
&gt;&gt;&gt; proc({'foo': 'bar'})
'bar'
&gt;&gt;&gt; proc({'foo': {'bar': 'baz'}})
{'bar': 'baz'}
</code></pre>

<blockquote>
<p>与JSON一起工作:</p>
</blockquote>
<pre><code class="shell">&gt;&gt;&gt; import json
&gt;&gt;&gt; proc_single_json_str = Compose(json.loads, SelectJmes(&quot;foo&quot;))
&gt;&gt;&gt; proc_single_json_str('{&quot;foo&quot;: &quot;bar&quot;}')
u'bar'
&gt;&gt;&gt; proc_json_list = Compose(json.loads, MapCompose(SelectJmes('foo')))
&gt;&gt;&gt; proc_json_list('[{&quot;foo&quot;:&quot;bar&quot;}, {&quot;baz&quot;:&quot;tar&quot;}]')
[u'bar']
</code></pre>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../11-scrapy_shell/" class="btn btn-neutral float-right" title="Scrapy shell">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../09-items/" class="btn btn-neutral" title="Items"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../09-items/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../11-scrapy_shell/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme.js" defer></script>
      <script src="../../search/main.js" defer></script>

</body>
</html>
